# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

"""This file contains BUILD extensions for generating source code from LLVM's
table definition files using the TableGen tool.

See http://llvm.org/cmds/tblgen.html for more information on the TableGen
tool.
TODO(chandlerc): Currently this expresses include-based dependencies as
"sources", and has no transitive understanding due to these files not being
correctly understood by the build system.
"""

load("@bazel_skylib//rules:run_binary.bzl", "run_binary")

def table_gen_library(name, tblgen, td_file, td_srcs, tbl_outs, extra_args = [], **kwargs):
    """table_gen_library() generates tabular code from a table definition file.

    Args:
      name: The name of the build rule for use in dependencies.
      tblgen: The binary used to produce the output.
      td_file: The primary table definitions file.
      td_srcs: A list of table definition files included transitively.
      tbl_outs: A list of tuples (opts, out), where each opts is a string of
        options passed to tblgen, and the out is the corresponding output file
        produced.
      library: Whether to bundle the generated files into a library.
      **kwargs: Keyword arguments to pass to subsidiary cc_library() rule.
    """
    if td_file not in td_srcs:
        td_srcs += [td_file]
    includes = []
    for (opts, out) in tbl_outs:
        outdir = out[:out.rindex("/")]
        if outdir not in includes:
            includes.append(outdir)
        rule_suffix = "_".join(opts.replace("-", "_").replace("=", "_").split(" "))
        run_binary(
            name = "%s_%s_run_binary" % (name, rule_suffix),
            srcs = td_srcs,
            outs = [out],
            tool = tblgen,
            args = [
                "$(location %s)" % td_file,
                "-I",
                "external/directx_shader_compiler/include",
                "-I",
                "external/directx_shader_compiler/tools/clang/include",
                "%s" % opts,
                "-o",
                "$(location %s)" % out,
            ] + extra_args,
        )

    native.cc_library(
        name = name,
        textual_hdrs = [f for (_, f) in tbl_outs],
        includes = includes,
        **kwargs
    )

def llvm_target_cmake_vars(native_arch, host_triple, target_triple):
    return {
        "LLVM_HOST_TRIPLE": host_triple,
        "LLVM_DEFAULT_TARGET_TRIPLE": target_triple,
        "LLVM_NATIVE_ARCH": native_arch,
    }

def cmake_var_string(cmake_vars):
    """Converts a dictionary to an input suitable for expand_cmake_vars.

    Ideally we would jist stringify in the expand_cmake_vars() rule, but select()
    interacts badly with genrules.

    TODO(phawkins): replace the genrule() with native rule and delete this rule.

    Args:
      cmake_vars: a dictionary with string keys and values that are convertable to
        strings.

    Returns:
      cmake_vars in a form suitable for passing to expand_cmake_vars.
    """
    return [
        "{}={}".format(k, str(v))
        for (k, v) in cmake_vars.items()
    ]

def expand_cmake_vars(name, src, dst, cmake_vars):
    """Expands #cmakedefine, #cmakedefine01, and CMake variables in a text file.

    Args:
      name: the name of the rule
      src: the input of the rule
      dst: the output of the rule
      cmake_vars: a string containing the CMake variables, as generated by
        cmake_var_string.
    """
    expand_cmake_vars_tool = "@directx_shader_compiler//:expand_cmake_vars"
    run_binary(
        name = name,
        srcs = [src],
        tool = expand_cmake_vars_tool,
        outs = [dst],
        args = [
            "$(location %s)" % src,
            "$(location %s)" % dst,
        ] + cmake_vars,
    )

def generate_etw_events(name, src, dst):
    """Expands #cmakedefine, #cmakedefine01, and CMake variables in a text file.

    Args:
      name: the name of the rule
      src: the input of the rule
      dst: the output of the rule
      cmake_vars: a string containing the CMake variables, as generated by
        cmake_var_string.
    """
    expand_cmake_vars_tool = "@toolchains//:mc"
    run_binary(
        name = name,
        srcs = [src],
        tool = expand_cmake_vars_tool,
        outs = [dst],
        args = [
            "$(location %s)" % src,
            "$(location %s)" % dst,
        ] + cmake_vars,
    )

# The set of CMake variables common to all targets.
cmake_vars = {
    # LLVM features
    "ENABLE_BACKTRACES": 1,
    "ENABLE_CRASH_OVERRIDES": 1,
    "DISABLE_LLVM_DYLIB_ATEXIT": 1,
    "ENABLE_PIC": 1,
    "ENABLE_TIMESTAMPS": 1,
    "LLVM_DISABLE_ABI_BREAKING_CHECKS_ENFORCING": 0,
    "LLVM_ENABLE_ABI_BREAKING_CHECKS": 0,
    "LLVM_ENABLE_THREADS": 1,
    "LLVM_ENABLE_ZLIB": 1,
    "LLVM_HAS_ATOMICS": 1,
    "LLVM_VERSION_MAJOR": 3,
    "LLVM_VERSION_MINOR": 7,
    "LLVM_VERSION_PATCH": 0,
    "PACKAGE_NAME": "LLVM",
    "PACKAGE_STRING": "LLVM 3.7-v1.5.2003",
    "PACKAGE_VERSION": "3.7-v1.5.2003",
    "RETSIGTYPE": "void",
}

# The set of CMake variables common to POSIX targets.
posix_cmake_vars = {
    # Headers
    "HAVE_DIRENT_H": 1,
    "HAVE_DLFCN_H": 1,
    "HAVE_ERRNO_H": 1,
    "HAVE_EXECINFO_H": 1,
    "HAVE_FCNTL_H": 1,
    "HAVE_INTTYPES_H": 1,
    "HAVE_PTHREAD_H": 1,
    "HAVE_SIGNAL_H": 1,
    "HAVE_STDINT_H": 1,
    "HAVE_SYS_IOCTL_H": 1,
    "HAVE_SYS_MMAN_H": 1,
    "HAVE_SYS_PARAM_H": 1,
    "HAVE_SYS_RESOURCE_H": 1,
    "HAVE_SYS_STAT_H": 1,
    "HAVE_SYS_TIME_H": 1,
    "HAVE_SYS_TYPES_H": 1,
    "HAVE_TERMIOS_H": 1,
    "HAVE_UNISTD_H": 1,
    "HAVE_ZLIB_H": 1,

    # Features
    "HAVE_BACKTRACE": 1,
    "BACKTRACE_HEADER": "execinfo.h",
    "HAVE_DLOPEN": 1,
    "HAVE_FUTIMES": 1,
    "HAVE_GETCWD": 1,
    "HAVE_GETPAGESIZE": 1,
    "HAVE_GETRLIMIT": 1,
    "HAVE_GETRUSAGE": 1,
    "HAVE_GETTIMEOFDAY": 1,
    "HAVE_INT64_T": 1,
    "HAVE_ISATTY": 1,
    "HAVE_LIBEDIT": 1,
    "HAVE_LIBPTHREAD": 1,
    "HAVE_LIBZ": 1,
    "HAVE_MKDTEMP": 1,
    "HAVE_MKSTEMP": 1,
    "HAVE_MKTEMP": 1,
    "HAVE_PREAD": 1,
    "HAVE_PTHREAD_GETSPECIFIC": 1,
    "HAVE_PTHREAD_MUTEX_LOCK": 1,
    "HAVE_PTHREAD_RWLOCK_INIT": 1,
    "HAVE_REALPATH": 1,
    "HAVE_SBRK": 1,
    "HAVE_SETENV": 1,
    "HAVE_SETRLIMIT": 1,
    "HAVE_SIGALTSTACK": 1,
    "HAVE_STRERROR": 1,
    "HAVE_STRERROR_R": 1,
    "HAVE_STRTOLL": 1,
    "HAVE_SYSCONF": 1,
    "HAVE_UINT64_T": 1,
    "HAVE__UNWIND_BACKTRACE": 1,

    # LLVM features
    "LLVM_ON_UNIX": 1,
    "LTDL_SHLIB_EXT": ".so",
    "LLVM_BINDIR": "/dev/null",
}

# CMake variables specific to the Linux platform
linux_cmake_vars = {
    "HAVE_MALLOC_H": 1,
    "HAVE_LINK_H": 1,
    "HAVE_MALLINFO": 1,
    "HAVE_FUTIMENS": 1,
}

# CMake variables specific to the Windows platform.
win32_cmake_vars = {
    # Headers
    "HAVE_ERRNO_H": 1,
    "HAVE_FCNTL_H": 1,
    "HAVE_FENV_H": 1,
    "HAVE_INTTYPES_H": 1,
    "HAVE_MALLOC_H": 1,
    "HAVE_SIGNAL_H": 1,
    "HAVE_STDINT_H": 1,
    "HAVE_SYS_STAT_H": 1,
    "HAVE_ZLIB_H": 1,
    "HAVE_LIMITS_H": 1,

    # Features
    "BACKTRACE_HEADER": "execinfo.h",
    "HAVE_INT64_T": 1,
    "HAVE_STRERROR": 1,
    "HAVE_STRTOLL": 1,
    "HAVE_SYSCONF": 1,
    "HAVE_UINT64_T": 1,
    "HAVE__CHSIZE_S": 1,
    "HAVE___CHKSTK": 1,
    "HAVE_DECL_STRERROR_S": 1,

    # MSVC specific
    "stricmp": "_stricmp",
    "strdup": "_strdup",
    "WIN32_ELMCB_PCSTR": "PCSTR",

    # LLVM features
    "LTDL_SHLIB_EXT": ".dll",
    "LLVM_ON_WIN32": 1,
}

def _dict_add(*dictionaries):
    """Returns a new `dict` that has all the entries of the given dictionaries.

    If the same key is present in more than one of the input dictionaries, the
    last of them in the argument list overrides any earlier ones.

    This function is designed to take zero or one arguments as well as multiple
    dictionaries, so that it follows arithmetic identities and callers can avoid
    special cases for their inputs: the sum of zero dictionaries is the empty
    dictionary, and the sum of a single dictionary is a copy of itself.

    Re-implemented here to avoid adding a dependency on skylib.

    Args:
      *dictionaries: Zero or more dictionaries to be added.

    Returns:
      A new `dict` that has all the entries of the given dictionaries.
    """
    result = {}
    for d in dictionaries:
        result.update(d)
    return result

# Select a set of CMake variables based on the platform.
# TODO(phawkins): use a better method to select the right host triple, rather
# than hardcoding x86_64.
llvm_all_cmake_vars = \
    cmake_var_string(cmake_vars) + \
    select({
        "@toolchains//conditions:windows": cmake_var_string(
            _dict_add(
                llvm_target_cmake_vars("X86", "x86_64-pc-win32", "dxil-ms-dx"),
                win32_cmake_vars,
            ),
        ),
        "@toolchains//conditions:linux": cmake_var_string(
            _dict_add(
                llvm_target_cmake_vars("X86", "x86_64-unknown-linux_gnu", "dxil-ms-dx"),
                posix_cmake_vars,
                linux_cmake_vars,
            ),
        ),
    })

llvm_linkopts = select({
    "@toolchains//conditions:windows": [],
    "@toolchains//conditions:linux": ["-ldl", "-lm", "-lpthread"],
})

llvm_defines = [
    "ENABLE_SPIRV_CODEGEN",
]

llvm_copts = select({
    "@toolchains//conditions:windows": [],
    "@toolchains//conditions:linux": [
        "-fms-extensions",
        "-Wno-language-extension-token",
    ],
})

# Platform specific sources for libSupport.

def llvm_support_platform_specific_srcs_glob():
    return select({
        "@toolchains//conditions:windows": native.glob([
            "lib/Support/Windows/*.inc",
            "lib/Support/Windows/*.h",
        ]),
        "@toolchains//conditions:linux": native.glob([
            "lib/Support/Unix/*.inc",
            "lib/Support/Unix/*.h",
        ]),
    })
